the righthand side.
# %T>% returns the lefthand side object of it instead of righthandsize to the next upcming object
rnorm(100) %>%
matrix(ncol=2)%T>%
plot() %>%
str()
mtcars %$%
cor(disp, mpg)
mtcars %>%
cor(disp, mpg)
mtcars$disp
mtcars$mpg
plot.default(mtcars$disp,mtcars$mpg)
mtcars %$%
(disp, mpg)
mtcars %>%
(disp, mpg)
mtcars %>% (disp, mpg)
mtcars %>% (disp,mpg)
mtcars
mtcars=as_tibble(mtcars)
mtcars
mtcars %>% (disp,mpg)
mtcars %>%
(disp,mpg)
mtcars %>%
filter(disp,mpg)
mtcars$disp
mtcars$mpg
plot.default(mtcars$disp,mtcars$mpg)
x <- c(1:10, Inf)
rescale01(x)
rescale01 <- function(x) {
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
}
x <- c(1:10, Inf)
rescale01(x)
range(2:20)
x <- c(1:10, Inf)
rescale01(x)
# load --------------------------------------------------------------------
identical(0L, 0)
source('~/R/R_Data_Analysis/Pipes_and_Functions.R')
object.size(mtcars)
wt_mean <- function(x, w, na.rm = FALSE) {
stopifnot(is.logical(na.rm), length(na.rm) == 1)
stopifnot(length(x) == length(w))
if (na.rm) {
miss <- is.na(x) | is.na(w)
x <- x[!miss]
w <- w[!miss]
}
sum(w * x) / sum(x)
}
wt_mean(1:6, 6:1, na.rm = "foo")
rule <- function(..., pad = "-") {
title <- paste0(...)
width <- getOption("width") - nchar(title) - 5
cat(title, " ", stringr::str_dup(pad, width), "\n", sep = "")
}
rule("Important output")
sum(x, na.mr = TRUE)
x <- c(1, 2)
sum(x, na.mr = TRUE)
?na.mr
x <- c(2, 2)
sum(x, na.mr = TRUE)
x <- c(1, 2)
sum(x, na.mr = TRUE)
x <- c(3, 2)
sum(x, na.mr = TRUE)
x <- c(4, 2)
sum(x, na.mr = TRUE)
x <- c(1, 2)
sum(x, na.mr = TRUE)
x <- c(2, 2)
sum(x, na.mr = TRUE)
x <- c(5, 2)
sum(x, na.mr = TRUE)
x <- c(6, 2)
sum(x, na.mr = TRUE)
mean(x, na.mr = TRUE)
max(x, na.mr = TRUE)
exp(x, na.mr = TRUE)
sub(x, na.mr = TRUE)
mean(x, na.mr = TRUE)
n <- sum(is.na(df))
show_missings <- function(df) {
n <- sum(is.na(df))
cat("Missing values: ", n, "\n", sep = "")
invisible(df)
}
x <- show_missings(mtcars)
class(x)
dim(x)
# add some NA values
mtcars %>%
show_missings() %>%
mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>%
show_missings()
y <- 100
f(10)
f <- function(x) {
x + y
}
y <- 100
f(10)
y <- 1000
f(10)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
library(tidyverse)
library(lubridate)
library(nycflights13)
library(magrittr)
typeof(1)
typeof(1L)
c(-1, 0, 1) / 0
x <- "This is a reasonably long string."
pryr::object_size(x)
y <- rep(x, 1000)
install.packages("pryr")
typeof(c(TRUE, 1L))
# Always the most complex type is taken by the vector
typeof(c(1L, 1.5))
x <- "This is a reasonably long string."
pryr::object_size(x)
y <- rep(x, 1000)
pryr::object_size(y)
library(pryr)
x <- "This is a reasonably long string."
pryr::object_size(x)
y <- rep(x, 1000)
pryr::object_size(y)
1:10 + 1:3
tibble(x = 1:4, y = rep(1:2, 2))
tibble(x = 1:4, y = rep(1:2, each = 2))
x <- c("one", "two", "three", "four", "five")
x[c(3, 2, 5)]
x[c(1, 1, 5, 5, 5, 2)]
x <- c(abc = 1, def = 2, xyz = 5)
x[c("xyz", "def")]
source('~/R/R_Data_Analysis/Vectors.R')
str(y[[1]])
a<- list(a = 1:3, b = "a string", c = pi, d = list(-1, -5))
str(y[[1]])
str(a[[1]])
str(a[1])
str(a)
str(a)
str(a[[1]])
str(a[1])
x <- factor(c("ab", "cd", "ab"), levels = c("ab", "cd", "ef"))
typeof(x)
x <- factor(c("ab", "cd", "ab"), levels = c("ab", "cd", "ef"))
typeof(x)
attributes(x)
x
x <- as.Date("1971-01-01")
unclass(x)
typeof(x)
attributes(x)
attr(x, "tzone") <- "US/Pacific"
x
attr(x, "tzone") <- "US/Eastern"
x
x <- lubridate::ymd_hm("1970-01-01 01:00")
attr(x, "tzone") <- "US/Pacific"
x
attr(x, "tzone") <- "US/Eastern"
x
y <- vector("double", 0)
y
seq_along(y)
1:length(y)
df <- tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
rng <- range(x, na.rm = TRUE)
rescale01 <- function(x) {
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
}
for (i in seq_along(df)) {
df[[i]] <- rescale01(df[[i]])
}
df
results <- vector("list", length(x))
names(results) <- names(x)
for (i in seq_along(x)) {
name <- names(x)[[i]]
value <- x[[i]]
}
x
means <- c(0, 1, 2)
output <- double()
for (i in seq_along(means)) {
n <- sample(100, 1)
output <- c(output, rnorm(n, means[[i]]))
}
str(output)
runif(10)
out <- vector("list", length(means))
for (i in seq_along(means)) {
n <- sample(100, 1)
out[[i]] <- rnorm(n, means[[i]])
}
str(out)
source('~/R/R_Data_Analysis/Vectors.R')
map_dbl(df, mean)
map_lgl(df,x>0.5)
df %>% map_dbl(sd)
models <- mtcars %>%
split(.$cyl) %>%
map(function(df) lm(mpg ~ wt, data = df))
models
mtcars %>%
split(.$cyl)
models %>%
map(summary) %>%
map_dbl(~.$r.squared)
models %>%
map(summary) %>%
map_dbl("r.squared")
x <- list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9))
x %>% map_dbl(2)
x1 <- list(
c(0.27, 0.37, 0.57, 0.91, 0.20),
c(0.90, 0.94, 0.66, 0.63, 0.06),
c(0.21, 0.18, 0.69, 0.38, 0.77)
)
x2 <- list(
c(0.50, 0.72, 0.99, 0.38, 0.78),
c(0.93, 0.21, 0.65, 0.13, 0.27),
c(0.39, 0.01, 0.38, 0.87, 0.34)
)
threshold <- function(x, cutoff = 0.8) x[x > cutoff]
x1 %>% sapply(threshold) %>% str()
safe_log <- safely(log)
str(safe_log(10))
is_ok <- y$error %>% map_lgl(is_null)
x[!is_ok]
x <- list(1, 10, "a")
x %>% map_dbl(possibly(log, NA_real_))
x <- list(1, 10, "a")
x %>% map_dbl(possibly(log, NA_real_))
x <- list(1, -1)
x %>% map(quietly(log)) %>% str()
mu <- list(5, 10, -3)
mu %>%
map(rnorm, n = 5) %>%
str()
# multiple related inputs
map2(mu, sigma, rnorm, n = 5) %>% str()
# multiple related inputs
sigma <- list(1, 5, 10)
map2(mu, sigma, rnorm, n = 5) %>% str()
n <- list(1, 3, 5)
args1 <- list(n, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
params <- tribble(
~mean, ~sd, ~n,
5, 1, 1,
10, 5, 3,
-3, 10, 5
)
params %>%
pmap(rnorm)
x <- list(1, "a", 3)
x %>%walk(print)
iris %>%
keep(is.factor) %>%
str()
iris %>%
discard(is.factor) %>%
str()
library(tidyverse)
library(modelr)
options(na.action = na.warn)
ggplot(sim1, aes(x, y)) +
geom_point()
models <- tibble(
a1=runif(250,-20,40)
a2=runif(250,-5,5)
)
models <- tibble(
a1=runif(250,-20,40)
a2=runif(250,-5,5)
)
models <- tibble(
a1=runif(250,-20,40)
a2=runif(250,-5,5)
)
models <- tibble(
a1=runif(250,-20,40),
a2=runif(250,-5,5)
)
models
sim1
ggplot(sim1,aes(x,y)) %>%
geom_abline(aes(intercept=a1,slope = a2),data=models,alpha=1/4) %>%
geom_point()
ggplot(sim1,aes(x,y)) +
geom_abline(aes(intercept=a1,slope = a2),data=models,alpha=1/4) +
geom_point()
model1 <- function(a, data) {
a[1] + data$x * a[2]
}
model1(c(7, 1.5), sim1)
measure_distance <- function(mod, data) {
diff <- data$y - model1(mod, data)
sqrt(mean(diff ^ 2))
}
measure_distance(c(7, 1.5), sim1)
sim1_dist <- function(a1, a2) {
measure_distance(c(a1, a2), sim1)
}
sim1_dist
sim1_dist
measure_distance(c(a1, a2), sim1)
measure_distance <- function(mod, data) {
diff <- data$y - model1(mod, data)
sqrt(mean(diff ^ 2))
}
measure_distance(c(7, 1.5), sim1)
sim1_dist <- function(a1, a2) {
measure_distance(c(a1, a2), sim1)
}
sim1_dist
sim1_dist
models <- models %>%
mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))
models
measure_distance(c(7, 1.5), sim1)
models
sim1
models
ggplot(sim1, aes(x, y)) +
geom_point(size = 2, color = "grey30") +
geom_abline(
aes(intercept = a1, slope = a2, color = -dist),
data = filter(models, rank(dist) <= 10)
)
data = filter(models, rank(dist) <= 10)
data
ggplot(models, aes(a1, a2)) +
geom_point(
data = filter(models, rank(dist) <= 10),
size = 4, color = "red"
) +
geom_point(aes(colour = -dist))
source('~/R/R_Data_Analysis/Models.R')
source('~/R/R_Data_Analysis/Models.R')
models
sim1
ggplot(sim1,aes(x,y)) +
geom_abline(aes(intercept=a1,slope = a2),data=models,alpha=1/4) +
geom_point()
model1 <- function(a, data) {
a[1] + data$x * a[2]
}
model1(c(7, 1.5), sim1)
measure_distance <- function(mod, data) {
diff <- data$y - model1(mod, data)
sqrt(mean(diff ^ 2))
}
measure_distance(c(7, 1.5), sim1)
sim1_dist <- function(a1, a2) {
measure_distance(c(a1, a2), sim1)
}
sim1_dist
models <- models %>%
mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))
models
ggplot(sim1, aes(x, y)) +
geom_point(size = 2, color = "grey30") +
geom_abline(
aes(intercept = a1, slope = a2, color = -dist),
data = filter(models, rank(dist) <= 10)
)
data = filter(models, rank(dist) <= 10)
data
ggplot(models, aes(a1, a2)) +
geom_point(
data = filter(models, rank(dist) <= 10),
size = 4, color = "red"
) +
geom_point(aes(colour = -dist))
grid <- expand.grid(
a1 = seq(-5, 20, length = 25),
a2 = seq(1, 3, length = 25)
) %>%
mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))
grid
grid %>%
ggplot(aes(a1, a2)) +
geom_point(
data = filter(grid, rank(dist) <= 10),
size = 4, colour = "red"
) +
geom_point(aes(color = -dist))
seq(-5, 20, length = 25)
expand.grid(
expand.grid(a1 = seq(-5, 20, length = 25)
expand.grid(a1 = seq(-5, 20, length = 25))
expand.grid(a1 = seq(-5, 20, length = 25))
expand.grid(a1 = seq(-5, 20, length = 25),a2 = seq(1, 3, length = 25))
a1
grid
ggplot(sim1, aes(x, y)) +
geom_point(size = 2, color = "grey30") +
geom_abline(
aes(intercept = a1, slope = a2, color = -dist),
data = filter(grid, rank(dist) <= 10)
)
# We need to give a starting value in optim
best <- optim(c(0, 0), measure_distance, data = sim1)
best$par
ggplot(sim1, aes(x, y)) +
geom_point(size = 2, color = "grey30") +
geom_abline(intercept = best$par[1], slope = best$par[2])
sim1_mod <- lm(y ~ x, data = sim1)
coef(sim1_mod)
sim1_mod
sim1_mod <- lm(y ~ ., data = sim1)
sim1_mod
coef(sim1_mod)
sim1_mod <- lm(y ~ x, data = sim1)
sim1_mod
coef(sim1_mod)
grid <- sim1 %>%
data_grid(x)
grid
sim1
grid
# adding the prediction from the previous model to the grid
grid <- grid %>%
add_predictions(sim1_mod)
grid
ggplot(sim1, aes(x)) +
geom_point(aes(y = y)) +
geom_line(aes(y = pred),
data = grid,
colour = "red",
size = 1
)
sim1 <- sim1 %>%
add_residuals(sim1_mod)
sim1
grid
ggplot(sim1, aes(resid)) +
geom_freqpoly(binwidth = 0.5)
ggplot(sim1, aes(x, resid)) +
geom_ref_line(h = 0) +
geom_point()
df <- tribble(
~y, ~x1, ~x2,
4, 2, 5,
5, 1, 6
)
model_matrix(df, y ~ x1)
df
model_matrix(df, y ~ x1)
df <- tribble(
~y, ~x1, ~x2,
4, 2, 5,
5, 1, 9
)
df
model_matrix(df, y ~ x1)
model_matrix(df, y ~ x1 - 1)
model_matrix(df, y ~ x1 + x2)
df <- tribble(
~ sex, ~ response,
"male", 1,
"female", 2,
"male", 1
)
model_matrix(df, response ~ sex)
sim2
print(sim2,x=inf)
print(sim2,n=inf)
print(sim2,n=Inf)
print(sim2,n=Inf,width=5)
print(sim2,n=Inf,width=Inf)
ggplot(sim2) +
geom_point(aes(x, y))
mod2 <- lm(y ~ x, data = sim2)
grid <- sim2 %>%
data_grid(x) %>%
add_predictions(mod2)
mod2
grid <- sim2 %>%
data_grid(x) %>%
add_predictions(mod2)
grid
ggplot(sim2, aes(x)) +
geom_point(aes(y = y)) +
geom_point(
data = grid,
aes(y = pred),
color = "red",
size = 4
)
tibble(x = "e") %>%
add_predictions(mod2)
