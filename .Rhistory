y <- c(1, 2, 2, NA, 3, 4)
min_rank(y)
row_number(y)
?row_number
dense_rank(y)
percent_rank(y)
cume_dist(y)
# Ranks element with the normalization by subtracting min value from every element and then divide by the new max value
# Rank range of all liies b/w 0 and 1 where minimum value has 0 and maximum has 1
#y Duplicates have same rank
percent_rank(y)
y
?perecent_rank
?percent_rank
str(flights)
transmutate(flights,dt_hr=dep_time%/%100,dt_min=dep_time%%100,sdt_hr=sched_dep_time%/%100,sdt_min=sched_dep_time%%100)
transmute(flights,dt_hr=dep_time%/%100,dt_min=dep_time%%100,sdt_hr=sched_dep_time%/%100,sdt_min=sched_dep_time%%100)
# Summarize() for getting values groupby
summarize(group_by(flights,year,month,day),delay=mean(dep_delay,na.rm=TRUE))
# Summarize() for getting values groupby
# Average delayfor every day of the year
summarize(group_by(flights,year,month,day),count=n(),delay=mean(dep_delay,na.rm=TRUE))
filter(delay,count>1000)
# Summarize() for getting values groupby
# Average delayfor every day of the year
# Count=n() for the count of total values or flights on that day
delay=summarize(group_by(flights,year,month,day),count=n(),delay=mean(dep_delay,na.rm=TRUE))
filter(delay,count>1000)
by_dest <- group_by(flights, dest)
delay <- summarize(by_dest,count = n(),dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE))
delay <- filter(delay, count > 20, dest != "HNL")
delay
ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
geom_point(aes(size = count), alpha = 1/3) +
geom_smooth(se = FALSE)
# The upper full code we can write in a compact way using pipe
delay <- flights %>% group_by(dest) %>%
summarize(count=n(),dist=mean(distance,na.rm=TRUE),delay=mean(arr_delay,na.rm=TRUE)) %>%
filter(count>20,dest!='HNL')
delay
source('~/R/R_Data_Analysis/dplyr_analysis.R')
not_cancelled %<% group_by(year,month,day) %<%
summarize(mean(dep_time))
not_cancelled %>% group_by(year,month,day) %>%
summarize(mean(dep_time))
not_cancelled <- flights %>%
filter(!is.na(dep_delay),!is.na(arr_delay))
not_cancelled %>% group_by(year,month,day) %>%
summarize(mean(dep_time))
not_cancelled %>% group_by(year,month,day) %>%
summarize(mean=mean(dep_time))
not_cancelled <- flights %>%
filter(!is.na(dep_delay),!is.na(arr_delay))
not_cancelled %>% group_by(year,month,day) %>%
summarize(mean=mean(dep_delay))
delays=not_cancelled %>% group_by(tailnum) %>% summarize(mean=mean(dep_delay))
ggplot(data=delays)+geom_freqpoly(mapping=aes(x=delays))
delays=not_cancelled %>% group_by(tailnum) %>% summarize(delay=mean(arr_delay))
ggplot(data=delays)+geom_freqpoly(mapping=aes(x=delay))
ggplot(data=delays)+geom_freqpoly(mapping=aes(x=delay),binwidth=10)
ggplot(data=delays)+geom_freqpoly(mapping=aes(x=delay),binwidth=50)
ggplot(data=delays)+geom_freqpoly(mapping=aes(x=delay),binwidth=30)
ggplot(data=delays)+geom_freqpoly(mapping=aes(x=delay),binwidth=10)
delays=not_cancelled %>% group_by(tailnum) %>% summarize(delay=mean(arr_delay),na.rm=TRUE)
ggplot(data=delays)+geom_point(mapping=aes(x=delay,y=count),alpha=1/10)
delays=not_cancelled %>% group_by(tailnum) %>% summarize(delay=mean(arr_delay),count=n(),na.rm=TRUE)
ggplot(data=delays)+geom_point(mapping=aes(x=delay,y=count),alpha=1/10)
# Neglecting the first first 25 counts
delays %>% filter(count>25) %>% ggplot(mapping=aes(x=delay,y=count))+
geom_point(alpha=1/10)
batting <- as_tibble(Lahman::Batting)
install.packages("Lahman")
batting <- as_tibble(Lahman::Batting)
install.packages("Lahman")
batting <- as_tibble(Lahman::Batting)
batters=batting %>% group_by(playerID) %>%
summarize(ba=sum(H,na.rm=TRUE)/sum(AB,na.rm=TRUE),ab=sum(AB,na.rm=TRUE))
batters
batters %>% filter(ab>25) %>% ggplot(mapping=aes(x=ab,y=ba))+
geom_point() + geom_smooth()
batters %>% filter(ab>25) %>% ggplot(mapping=aes(x=ab,y=ba))+
geom_point() + geom_smooth(se=FALSE)
not_cancelled %>% group_by(year,month,day) %>%
summarize(avg_delay1=mean(arr_delay),avg_delay2=mean(arr_delay[arr_delay>0]))
not_cancelled %>% group_by(dest) %>%
summarize(sd=sd(distance)) %>% arrange(desc(sd))
not_cancelled %>% group_by(year, month, day) %>%
summarize(first = min(dep_time),last = max(dep_time))
# We can also use first() and last() at the place of min and max
not_cancelled %>%group_by(year, month, day) %>%
summarize(first_dep = first(dep_time),last_dep = last(dep_time))
not_cancelled %>%group_by(year, month, day) %>%
mutate(r = min_rank(desc(dep_time))) %>%filter(r %in% range(r))
not_cancelled %>% group_by(dest) %>%
summarize(carriers=n_distinct(carrier)) %>% arrange(desc(carriers))
not_cancelled$carrier
not_cancelled %>% count(dest)
not_cancelled %>% count(tailnum, wt = distance)
ot_cancelled %>% group_by(year, month, day) %>%
summarize(n_early = sum(dep_time < 500))
not_cancelled %>% group_by(year, month, day) %>%
summarize(n_early = sum(dep_time < 500))
# What proportion of flights are delayed by more than an hour?
not_cancelled %>% group_by(year, month, day) %>%
summarize(hour_perc = mean(arr_delay > 60))
daily <- group_by(flights, year, month, day)
# daily no. of flights
(per_day <- summarize(daily, flights = n()))
(per_month <- summarize(per_day, flights = sum(flights)))
# Yearly no. of flights
(per_year <- summarize(per_month, flights = sum(flights)))
daily %>% ungroup() %>%
summarize(flights = n())
daily <- group_by(flights, year, month, day)
daily
popular_dests <- flights %>%group_by(dest) %>%
filter(n() > 365)
popular_dests
popular_dests <- flights %>% group_by(dest) %>%
filter(n() > 365)
popular_dests
popular_dests %>% filter(arr_delay > 0) %>%
mutate(prop_delay = arr_delay / sum(arr_delay)) %>%
select(year:day, dest, arr_delay, prop_delay)
library(tidyverse)
library(nycflights13)
nycflights13::flights
str(flights)
diamonds
str(diamonds)
str(mpg)
# Categorical
ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut))
diamonds %>%count(cut)
# Continuous
ggplot(data = diamonds) + geom_histogram(mapping = aes(x = carat), binwidth = 0.5)
diamonds
str(diamonds)
diamonds %>% count(cut_width(carat, 0.5))
smaller <- diamonds %>%filter(carat < 3)
ggplot(data = smaller, mapping = aes(x = carat)) +geom_histogram(binwidth = 0.1)
ggplot(data = smaller, mapping = aes(x = carat, color = cut)) +geom_freqpoly(binwidth = 0.1)
ggplot(data = smaller, mapping = aes(x = carat)) +geom_histogram(binwidth = 0.01)
faithful
ggplot(data = faithful, mapping = aes(x = eruptions)) +geom_histogram(binwidth = 0.25)
ggplot(diamonds) + geom_histogram(mapping = aes(x = y), binwidth = 0.5)
# Zoom on y-axis to see outliers
ggplot(diamonds) + geom_histogram(mapping = aes(x = y), binwidth = 0.5) +
coord_cartesian(ylim = c(0, 50))
unusual <- diamonds %>% filter(y < 3 | y > 20) %>% arrange(y)
unsual
unusual
diamonds2 <- diamonds %>% filter(between(y, 3, 20))
ggplot(diamonds) + geom_histogram(mapping = aes(x = y), binwidth = 0.5)
# Zoom on y-axis to see outliers using coord_cartesian
ggplot(diamonds) + geom_histogram(mapping = aes(x = y), binwidth = 0.5) +
coord_cartesian(ylim = c(0, 50))
unusual <- diamonds %>% filter(y < 3 | y > 20) %>% arrange(y)
unusual
diamonds2 <- diamonds %>% filter(between(y, 3, 20))
diamonds2 <- diamonds %>%  mutate(y = ifelse(y < 3 | y > 20, NA, y))
ggplot(data = diamonds2, mapping = aes(x = x, y = y)) + geom_point()
# we can also use the following to avoid warning
ggplot(data = diamonds2, mapping = aes(x = x, y = y)) +
geom_point(na.rm = TRUE)
nycflights13::flights %>%  mutate(cancelled = is.na(dep_time),sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,sched_dep_time = sched_hour + sched_min / 60) %>%
ggplot(mapping = aes(sched_dep_time)) +
geom_freqpoly( mapping = aes(color = cancelled),binwidth = 1/4 )
ggplot(data = diamonds, mapping = aes(x = price)) +
geom_freqpoly(mapping = aes(color = cut), binwidth = 500)
ggplot( data = diamonds, mapping = aes(x = price, y = ..density..)) +
geom_freqpoly(mapping = aes(color = cut), binwidth = 500)
str(diamonds)
# Box plot is a better graph to interpret
ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
geom_boxplot()
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) +
geom_boxplot()
# Flipping the axis
ggplot(data = mpg) +geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median),y = hwy))
ggplot(data = diamonds) +
geom_count(mapping = aes(x = cut, y = color))
diamonds %>% count(color, cut) %>%
ggplot(mapping = aes(x = color, y = cut)) +
geom_tile(mapping = aes(fill = n))
# Using geom_tile which is a kind of heatmap
diamonds %>% count(color, cut) %>%
ggplot(mapping = aes(x = color, y = cut)) +
geom_tile(mapping = aes(fill = n))
library(tidyverse)
library(nycflights13)
nycflights13::flights
str(flights)
diamonds
str(diamonds)
str(mpg)
ggplot(diamonds) +
geom_point(aes(x=carat,y=price),color='green')
ggplot(diamonds) +
geom_point(aes(x=carat,y=price),color='green',alpha=1/10)
install.packages("hexbin")
ggplot(diamonds) +
geom_box2d(aes(x=carat,y=price),color='green',alpha=1/10)
ggplot(diamonds) +
geom_bin2d(aes(x=carat,y=price),color='green',alpha=1/10)
ggplot(diamonds) +
geom_bin2d(aes(x=carat,y=price),alpha=1/10)
ggplot(diamonds) +
geom_bin2d(aes(x=carat,y=price))
ggplot(diamonds) +
geom_point(aes(x=carat,y=price),color='green',alpha=1/10)
library(hexbin)
ggplot(diamonds) +
geom_hex(aes(x=carat,y=price),color='green',alpha=1/10)
ggplot(diamonds) +
geom_hex(aes(x=carat,y=price))
smaller <- diamonds %>%filter(carat < 3)
diamonds %>% count(cut_width(carat, 0.5))
ggplot(smaller,mapping=aes(x=carat,y=price)) +
geom_boxplot(aes(group=cut_width(carat,0.1)),color='green',alpha=1/10)
ggplot(smaller,mapping=aes(x=carat,y=price)) +
geom_boxplot(aes(group=cut_width(carat,0.1)),alpha=1/10)
ggplot(smaller,mapping=aes(x=carat,y=price)) +
geom_boxplot(aes(group=cut_width(carat,0.1),FUNC=median),alpha=1/10)
ggplot(smaller,mapping=aes(x=carat,y=price)) +
geom_boxplot(aes(group=cut_width(carat,0.1),FUN=median),alpha=1/10)
ggplot(smaller,mapping=aes(x=carat,y=price)) +
geom_boxplot(aes(group=cut_width(carat,0.1),reorder(FUN=median)))
ggplot(smaller,mapping=aes(x=carat,y=price)) +
geom_boxplot(aes(group=cut_width(carat,0.1),reorder(carat,price,FUN=median)))
ggplot(smaller,mapping=aes(x=carat,y=price)) +
geom_boxplot(aes(group=cut_width(carat,0.1),x=reorder(carat,price,FUN=median)))
ggplot(smaller,mapping=aes(x=carat,y=price)) +
geom_boxplot(aes(group=cut_width(carat,0.1)))
ggplot(smaller,mapping=aes(x=carat,y=price)) +
geom_boxplot(aes(group=cut_width(carat,0.1),group=reorder(carat,price,FUN = median)))
# Boxplot size on the basis of count
ggplot(smaller,mapping=aes(x=carat,y=price)) +
geom_boxplot(aes(group=cut_number(carat,20)))
ggplot(diamonds) +
geom_point(aes(x=price,y=carat),color='green',alpha=1/10)
ggplot(diamonds) +
geom_point(aes(x=price,y=carat,group=cut),color='green',alpha=1/10)
ggplot(diamonds) +
geom_point(aes(x=price,y=carat,group=cut))
str(diamonds)
ggplot(diamonds) +
geom_point(aes(x=price,y=carat,color=cut))
ggplot(diamonds) +
geom_point(aes(y=price,x=carat,color=cut))
ggplot(diamonds) +
geom_point(aes(y=price,x=carat))+
geom_freqpoly(aes(x=cut))
ggplot(diamonds) +
geom_point(aes(y=cut,x=carat))+
geom_freqpoly(aes(x=price))
ggplot(diamonds) +
geom_point(aes(y=carat,x=cut))+
geom_freqpoly(aes(x=price))
ggplot(diamonds) +
geom_point(aes(y=carat,x=cut))+
geom_histogram(aes(x=price))
ggplot(diamonds) +
geom_point(aes(y=carat,x=cut))+
geom_histogram(aes(x=carat))
ggplot(diamonds) +
geom_point(aes(y=price,x=cut))+
geom_line(aes(x=cut,y=carat))
ggplot(diamonds) +
geom_bar(aes(y=price,x=carat,color=cut))
ggplot(diamonds) +
geom_histogram(aes(y=price,x=carat,color=cut))
# Count diagram for x and y corelations
ggplot(data = diamonds) +
geom_count(mapping = aes(x = cut, y = color))
ggplot(diamonds) +
geom_line(aes(y=price,x=carat,color=cut))
ggplot(diamonds) +
geom_line(aes(y=price,x=carat))
ggplot(diamonds) +
geom_point(aes(y=price,x=carat))
ggplot(diamonds) +
geom_point(aes(y=price,x=carat,group=cut))
ggplot(diamonds, aes(x = cut_number(carat, 5), y = price, colour = cut)) +
geom_boxplot()
ggplot(diamonds, aes(x = cut_number(carat, 5), y = price, color = cut)) +
geom_boxplot()
ggplot(diamonds, aes(colour = cut_number(carat, 5), y = price, x = cut)) +
geom_boxplot()
# displaying same no. of ponts in each bin this will change the bin width
ggplot(smaller,mapping=aes(x=carat,y=price)) +
geom_boxplot(aes(group=cut_number(carat,5)))
ggplot(diamonds, aes(x = cut_number(carat, 5), y = price, color = cut)) +
geom_boxplot()
ggplot(diamonds, aes(colour = cut_number(carat, 5), y = price, x = cut)) +
geom_boxplot()
library(modelr)
mod <- lm(log(price) ~ log(carat), data = diamonds)
source('~/R/R_Data_Analysis/Exploratory_Analysis.R')
diamonds2 <- diamonds %>%
add_residuals(mod) %>%
mutate(resid = exp(resid))
ggplot(data = diamonds2) +
geom_point(mapping = aes(x = carat, y = resid))
ggplot(data = diamonds2) +
geom_boxplot(mapping = aes(x = cut, y = resid))
library(tidyverse)
library(nycflights13)
as_tibble(iris)
tribble(
~x, ~y, ~z,
#--|--|----
"a", 2, 3.6,
"b", 1, 8.5)
tibble(
a = lubridate::now() + runif(1e3) * 86400,
b = lubridate::today() + runif(1e3) * 30,
c = 1:1e3,
d = runif(1e3),
e = sample(letters, 1e3, replace = TRUE)
)
runif(1e3)
lubridate::now()
nycflights13::flights %>%
print(n = 10, width = Inf)
class(as.data.frame(tb))
class(as.data.frame(fkights))
class(as.data.frame(flights))
read_csv("a,b,c1,2,3,4,5,6")
read_csv("a,b,c
1,2,3
4,5,6")
read_csv("The first line of metadata
The second line of metadata
x,y,z
1,2,3", skip = 2)
read_csv("1,2,3\n4,5,6", col_names = FALSE)
read_csv("1,2,3\n4,5,6", col_names = c("x", "y", "z"))
read_csv("a,b,c\n1,2,.", na = ".")
str(parse_logical(c("TRUE", "FALSE", "NA")))
str(parse_integer(c("1", "2", "3")))
str(parse_date(c("2010-01-01", "1979-10-14")))
parse_integer(c("123", "345", "abc", "123.45"))
problems(x)
# Now we get an error in 3rd and 4th term
x <- parse_integer(c("123", "345", "abc", "123.45"))
problems(x)
parse_double("1.23")
parse_double("1,23", locale = locale(decimal_mark = ","))
# using locale to identify decimal point
parse_double("1.23")
parse_double("1,23", locale = locale(decimal_mark = ","))
# parse_number ignores nonnumeric characters before and after the number.
parse_number("$100")
parse_number("20%")
parse_number("It cost $123.45")
# using locale to identify number
parse_number("123.456.789",locale = locale(grouping_mark = "."))
parse_number("123'456'789",locale = locale(grouping_mark = "'"))
# ASCII values
charToRaw("Hadley")
# ASCII values
charToRaw("Hadley")
x1 <- "El Ni\xf1o was particularly bad this year"
x2 <- "\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd"
# using different encoders
parse_character(x1, locale = locale(encoding = "Latin1"))
parse_character(x2, locale = locale(encoding = "Shift-JIS"))
# guessing the encoding of a value
guess_encoding(charToRaw(x1))
guess_encoding(charToRaw(x2))
fruit <- c("apple", "banana")
parse_factor(c("apple", "banana", "bananana"), levels = fruit)
parse_datetime("2010-10-01T2010")
parse_datetime("20101010")
parse_date("2010-10-01")
parse_time("01:10 am")
parse_time("20:10:01")
parse_date("01/02/15", "%m/%d/%y")
parse_date("01/02/15", "%d/%m/%y")
parse_date("01/02/15", "%y/%m/%d")
# parsing language argument
parse_date("1 janvier 2015", "%d %B %Y", locale = locale("fr"))
# parsing language argument
parse_date("1 janvier 2015", "%d %B %Y", locale = locale("hi"))
date_names_langs()
# parsing language argument
parse_date("1 jan 2015", "%d %B %Y", locale = locale("en"))
# parsing language argument
parse_date("1 january 2015", "%d %B %Y", locale = locale("en"))
# parsing language argument
parse_date("1 janvier 2015", "%d %B %Y", locale = locale("fr"))
date_names_langs()
# guess_parser to guess the parsing
guess_parser("2010-10-01")
guess_parser("15:01")
guess_parser(c("TRUE", "FALSE"))
guess_parser(c("1", "5", "9"))
guess_parser(c("12,352,561"))
str(parse_guess("2010-10-10"))
challenge <- read_csv(readr_example("challenge.csv"))
problems(challange)
problems(challenge)
# To avoid that we can define col
challenge <- read_csv(
readr_example("challenge.csv"),
col_types = cols(
x = col_double(),
y = col_character() ))
tail(challenge)
challenge <- read_csv(
readr_example("challenge.csv"),
col_types = cols(
x = col_double(),
y = col_date() ))
tail(challenge)
source('~/R/R_Data_Analysis/Data_importion.R')
challenge2
challenge2 <- read_csv(readr_example("challenge.csv"),
col_types = cols(.default = col_character()) )
challenge2
df <- tribble(
~x, ~y,
"1", "1.21",
"2", "2.32",
"3", "4.56"
)
df
type_convert(df)
write_csv(challenge, "challenge-2.csv")
read_csv("challenge-2.csv")
# rds store data in R’s custom binary format called RDS
write_rds(challenge, "challenge.rds")
read_rds("challenge.rds")
# The feather package implements a fast binary file format that
# can be shared across programming languages
#library(feather)
write_feather(challenge, "challenge.feather")
# The feather package implements a fast binary file format that
# can be shared across programming languages
library(feather)
install.packages("feather")
write_feather(challenge, "challenge.feather")
# The feather package implements a fast binary file format that
# can be shared across programming languages
library(feather)
write_feather(challenge, "challenge.feather")
read_feather("challenge.feather")
table1
table2
table3
table4a
table4b
table1 %>%
mutate(rate = cases / population * 10000)
table1 %>%
count(year, wt = cases)
ggplot(table1, aes(year, cases)) +
geom_line(aes(group = country), color = "grey50") +
geom_point(aes(color = country))
# gathering
table4a
gather('1999','2000',key=year,values=count)
gather('1999','2000',key=year,value=count)
gather('1999','2000',key='year',value='count')
gather(table4a,'1999','2000',key='year',value='count')
gather(table4a,'1999','2000',key='year',value='cases')
table4b %>%
gather(`1999`, `2000`, key = "year", value = "population")
tidy4a <- table4a %>%
gather(`1999`, `2000`, key = "year", value = "cases")
tidy4b <- table4b %>%
gather(`1999`, `2000`, key = "year", value = "population")
left_join(tidy4a, tidy4b)
# Spreading increases the data width
table 4b
# Spreading increases the data width
table4b
# Spreading increases the data width
table2
spread(table2, key=type, value=count )
# separate() pulls apart one column into multiple columns, by splitting
# wherever a separator character appears.
table3
separate(table3,rate=c('cases','population'))
separate(table3,rate,into=c('cases','population'))
table3 %>%
separate(rate, into = c("cases", "population"), sep = "/")
# separate make the columns as char type by default
# But we can change it to a better type using convvert=TRUE
table3 %>%
separate(
rate,
into = c("cases", "population"),
convert = TRUE
)
table3 %>%
separate(year, into = c("century", "year"), sep = 2)
# Unite
table5
unit(table5,century,year)
unit(table5,new,century,year)
unit(table5,new,century, year)
table5 %>%
unite(new, century, year)
unite(table5,new, century, year)
unite(table5,new,century, year)
# unite unite the values of two columns using default _ sign
table5 %>%
unite(new, century, year, sep = "")
