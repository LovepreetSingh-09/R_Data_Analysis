
library(tidyverse)
library(nycflights13)

x1 <- c("Dec", "Apr", "Jan", "Mar")
x2 <- c("Dec", "Apr", "Jam", "Mar")
sort(x1)

month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun",
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")

y1 <- factor(x1, levels = month_levels)
y1
sort(y1)

y2 <- factor(x2, levels = month_levels)
# values not in levels get NA value
y2
# To get an error
y2 <- parse_factor(x2, levels = month_levels)

# Levels generated by default are in ascending alphabetical order
factor(x1)

# To get the level same as the values use unique or 
f1 <- factor(x1, levels = unique(x1))
f1
f1 <- factor(x1, fct_inorder(x1))
f1
f2 <- x1 %>% factor() %>% fct_inorder()
f2
levels(f2)

gss_cat
gss_cat %>%
  count(race)

ggplot(gss_cat,aes(race)) +
  geom_bar()

# By default, ggplot2 will drop levels that donâ€™t have any values
# scale_x_discrete() is used to show the levels that have no value in the tibble
ggplot(gss_cat,aes(race)) +
  geom_bar() + scale_x_discrete(drop=FALSE)

religon=gss_cat %>%
  group_by(relig) %>% summarize(age=mean(age,na.rm=T),tvhours=mean(tvhours,na.rm=T),n=n())
religon
ggplot(religon)+
  geom_point(aes(tvhours,relig))

religon$relig
levels(religon$relig)
# fct_reorder to reorder the relig on the basis of tvhours  
# The values don't change but the levels are get sorted in ascending order based on the condition
fct_reorder(religon$relig, religon$tvhours)
ggplot(religon, aes(tvhours, fct_reorder(relig, tvhours))) +
  geom_point()
religon %>%
  mutate(relig = fct_reorder(relig, tvhours)) %>%
  ggplot(aes(tvhours, relig)) +
  geom_point()

religon %>%
  mutate(relig = fct_reorder(relig, tvhours))

rincome <- gss_cat %>%
  group_by(rincome) %>%
  summarize(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )
rincome

ggplot( rincome, aes(age, fct_reorder(rincome, age))) +
  geom_point()

# fct_relevel brings the specified level at the front here 'Not applicable'
ggplot( rincome, aes(age, fct_relevel(rincome, "Not applicable"))) +
  geom_point()

gss_cat %>% filter(!is.na(age)) %>%count(marital)
by_age <- gss_cat %>% filter(!is.na(age)) %>%
  group_by(age, marital) %>% count() %>%
  mutate(prop = n / sum(n)) 
by_age

ggplot(by_age, aes(age, n, color = marital)) +
  geom_line(na.rm = TRUE)
# fct_reorder2() reorders the factor by the y values associated with the largest x values.
ggplot( by_age,aes(age, n, color = fct_reorder2(marital, age, n))) +
  geom_line() +labs(color = "marital")

# fct_infreq() to order levels in increasing frequency
# but in ggplot it displayed graph in decreasing order so use fct_rev to reverse the level
gss_cat %>%
  mutate(marital = marital %>% fct_infreq() %>% fct_rev()) %>%
  ggplot(aes(marital)) +
  geom_bar()
m=gss_cat %>%
  transmute(marital = marital %>% fct_infreq() %>% fct_rev()) %>% count(marital)
print(m$marital)

# Modifying Values using fct_recode()
gss_cat %>% count(partyid)
gss_cat %>% mutate(partyid = fct_recode(partyid,
                              "Republican, strong" = "Strong republican",
                              "Republican, weak" = "Not str republican",
                              "Independent, near rep" = "Ind,near rep",
                              "Independent, near dem" = "Ind,near dem",
                              "Democrat, weak" = "Not str democrat",
                              "Democrat, strong" = "Strong democrat" )) %>%
  count(partyid)
# We can also combine groups or collapse(combine) using fct_recode
gss_cat %>% mutate(partyid = fct_recode(partyid,
                              "Republican, strong" = "Strong republican",
                              "Republican, weak" = "Not str republican",
                              "Independent, near rep" = "Ind,near rep",
                              "Independent, near dem" = "Ind,near dem",
                              "Democrat, weak" = "Not str democrat",
                              "Democrat, strong" = "Strong democrat",
                              "Other" = "No answer",
                              "Other" = "Don't know",
                              "Other" = "Other party")) %>%
  count(partyid)

gss_cat %>%mutate(partyid = fct_collapse(partyid,
                                other = c("No answer", "Don't know", "Other party"),
                                rep = c("Strong republican", "Not str republican"),
                                ind = c("Ind,near rep", "Independent", "Ind,near dem"),
                                dem = c("Not str democrat", "Strong democrat"))) %>%
  count(partyid)

# fct_lump combines or lump the all small groups together
gss_cat %>%
  mutate(relig = fct_lump(relig)) %>%
  count(relig)
# give n value to decide the total no. of groups after lump
gss_cat %>%
  mutate(relig = fct_lump(relig, n = 10)) %>%
  count(relig, sort = TRUE) %>%
  print(n = Inf)
